In this example we create a CNOT(2,2) gate, which means that we have a qubit acting as the control and another qubit acting as the target. If the control qubit is in mode 0, nothing happens to the target qubit. If the control qubit is in mode 1, we flip (i.e., swap 0 ↔ 1) the target qubit.

We express this transformation in the key word "target_state". The values in "target_state" decode as follows (reading the first two digits as input, the last two as output):

• "0000" means |00> → |00>  
• "0101" means |01> → |01>  
• "1011" means |10> → |11>  
• "1110" means |11> → |10>  

The keyword "in_nodes":  
• [0,1] indicates that the first two numbers in each entry of "target_state" correspond to the incoming qubits.  

The keyword "out_nodes":  
• [2,3] indicates that the third and fourth numbers in each entry of "target_state" correspond to the outgoing qubits.  

This transformation uses two ancillary photons, added via the "num_anc" parameter. These are single photons from external sources, as specified by the keyword "single_emitters":  
• [4, 5] denotes two single-photon emitters that supply the required ancilla photons.

incoming: [0 control qubit][1 target qutrit][4 anc. sps][5 anc. sps]
setup: [result of optimization]
detectors: [2 out][3 out][anc. det.][anc. det.]

We set "heralding_out" to true so that the correct operation of the gate is signaled (heralded) when the ancillary detectors click. The threshold parameters (under "thresholds") and other entries (such as "bulk_thr", "loss_func", "optimizer", and "tries_per_edge") govern the optimization process. 

