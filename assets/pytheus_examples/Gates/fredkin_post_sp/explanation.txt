In this example we create a post-selected Fredkin gate, which means that we have one control qubits acting on two target qubits.

If the control qubit is in mode 0, nothing is changed in the target qubits.
If the control qubit is in mode 1, the target qubits are swapped.

We express this transformation in the key word 'target_state'.

We can read the value for 'target_state'

    "000000" means |000> -> |000>
    "001001" means |001> -> |001>
    "010010" means |010> -> |010>
    "011011" means |011> -> |011>
    "100100" means |100> -> |100>
    "101110" means |101> -> |110>
    "110101" means |110> -> |101>
    "111111" means |111> -> |111>

the value for the keyword 'in_nodes' being [0,1,2] expresses that the first three numbers are the incoming particles.

the value for the keyword 'out_nodes' being [3,4,5] expresses that the fourth, fifth and sixth number are the outgoing particles.

This transformation requires one ancillary photon which is created from a single-photon emitter.

We introduce the single photon emitter with the keyword "single_emitters".

We can visualize the setup in the following way (with the photons going from top to bottom):

incoming: [0 control qubit][1 target qubit][2 target qutrit][6 anc. sps]
setup: [result of optimization]
detectors: [3 out][4 out][5 out][anc. det.][anc. det.]

The keyword "number_resolving" is set to true which means that number resolving detectors are used.

We set "heralding_out" to null (default is false) so for the correct operation of the gate all detectors (output detectors and ancilla detectors) have to click. The threshold parameters (under "thresholds") and other entries (such as "bulk_thr", "loss_func", "optimizer", and "tries_per_edge") govern the optimization process. 